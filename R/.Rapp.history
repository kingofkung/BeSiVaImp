names(dvdat) <- 'DV'
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rnorm(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]
Deev
names(aivdat)
singregs <-  lapply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), ' ~ ', paste(names(aivees), names(column), collapse = '+'))#
		glm(as.formula(form), family = famiglia)#
	}#
	)
singregs <-  lapply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), ' ~ ', paste(names(aivees), names(column), collapse = '+'))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys)#
#
	singregs <-  lapply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), ' ~ ', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys)#
#
	singregs <-  lapply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys)#
#
	singregs <-  lapply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		print(names(column))#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
singregs <-  lapply(Ivys, function(column = Ivys, aivees = aivdat, famiglia = fam){#
		print(names(column))#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
singregs <-  lapply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		print(names(column))#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
Ivys
names(Ivys)
names(Ivys[3])
paste(names(aivees), names(column), collapse = ' + ')
singregs <-  lapply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		print(column)#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
singregs <-  apply(Ivys, function(column, aivees = aivdat, famiglia = fam){#
		print(column)#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
# singregs <-  apply(Ivys, 2, FUN = function(column, aivees = aivdat, famiglia = fam){#
		# print(column)#
		# form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# # glm(as.formula(form), family = famiglia)#
	# }#
	# )
singregs <-  apply(Ivys, 2, FUN = function(column, aivees = aivdat, famiglia = fam){#
		print(column)#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
singregs <-  apply(Ivys, 2, FUN = function(column, aivees = aivdat, famiglia = fam){#
		print(names(column))#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
singregs <-  apply(Ivys, 2, FUN = function(column, aivees = aivdat, famiglia = fam){#
		print(labels(column))#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
print(labels(column))
singregs <-  lapply(Ivys, FUN = function(column, aivees = aivdat, famiglia = fam){#
		print(labels(column))#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
	}#
	)
singregs <-  lapply(Ivys, FUN = function(column, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), '~', paste(names(aivees), names(column), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
#
		print(form)#
	}#
	)
names(column)
singregs <-  lapply(Ivys, FUN = function(x, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), '~', paste(names(aivees), names(x), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
#
		print(form)#
	}#
	)
singregs <-  lapply(Ivys, FUN = function(col, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), '~', paste(names(aivees), names(col), collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
#
		print(form)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam){#
		form <- paste(names(Deev), '~', paste(names(aivees), col, collapse = ' + '))#
		# glm(as.formula(form), family = famiglia)#
#
		print(form)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam){#
#
		Ivform <-  paste(names(aivees), col, collapse = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		# glm(as.formula(form), family = famiglia)#
#
		print(form)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam){#
#
		Ivform <-  paste(names(aivees), col, collapse = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		# glm(as.formula(form), family = famiglia)#
#
		print(Ivform)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam){#
#
		Ivform <-  paste(names(aivees), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		# glm(as.formula(form), family = famiglia)#
#
		print(Ivform)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam){#
#
		Ivform <-  paste(paste(names(aivees), collapse = '+'), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		# glm(as.formula(form), family = famiglia)#
#
		print(Ivform)#
	}#
	)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
	singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam, alldat <- data.frame(Deev, Ivys)){#
#
		Ivform <-  paste(paste(names(aivees), collapse = '+'), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		# glm(as.formula(form), family = famiglia)#
#
		print(Ivform)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam, alldat = data.frame(Deev, Ivys)){#
#
		Ivform <-  paste(paste(names(aivees), collapse = '+'), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		# glm(as.formula(form), family = famiglia)#
#
		print(Ivform)#
	}#
	)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
	singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam, alldat = data.frame(Deev, Ivys)){#
#
		Ivform <-  paste(paste(names(aivees), collapse = '+'), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
#
		print(Ivform)#
	}#
	)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
	singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(names(aivees), collapse = '+'), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
#
		print(Ivform)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = aivdat, famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(names(aivees), collapse = '+'), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')#
		form <- paste(names(Deev), '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, dvname = names(Deev) aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
	}#
	)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rnorm(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
	singregs <-  lapply(names(Ivys), FUN = function(col, dvname = names(Deev) aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
	}#
	)
singregs <-  lapply(names(Ivys), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
	}#
	)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rnorm(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
	singregs <-  lapply(names(Ivys), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
	}#
	)#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rnorm(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'binomial'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
	singregs <-  lapply(names(Ivys), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
		critergen()#
	}#
	)#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rnorm(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'binomial'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
		critergen()#
	}#
	)#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + '))#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
		critergen()#
	}#
	)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + '))#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
		critergen()#
	}#
	)
singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + '))#
		form <- paste(dvname, '~', Ivform)#
		glm(as.formula(form), family = famiglia, data = alldat)#
	}#
	)
singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = data.frame(Deev, aivdat, Ivys)){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + '))#
		form <- paste(dvname, '~', Ivform)#
		lm(as.formula(form), data = alldat)#
	}#
	)
subsetter <- function(dataframe){#
	fulllength <- nrow(dataframe)#
	print(fulllength)#
	print(round(fulllength/10))#
}
subsetter <- function(dataframe){#
	fulllen <- nrow(dataframe)#
#
	ptestlen <- round(fulllen/10)#
	sample(fulllen, ptestlen)#
}
subsetter(Ivys)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){#
	fulllen <- nrow(dataframe)#
#
	ptestlen <- round(fulllen/10)#
	sample(fulllen, ptestlen)#
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		lm(as.formula(form), data = alldat)#
	}#
	)
subsetter(fdf)
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe)#
#
	ptestlen <- round(fulllen/10)#
	sample(fulllen, ptestlen)#
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		lm(as.formula(form), data = alldat)#
	}#
	)
lapply(singregs, summary)
lapply(singregs, length)
lapply(singregs, function(x) length(residuals(x)) )
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe)#
#
	ptestlen <- round(fulllen/10)#
	sample(fulllen, ptestlen)#
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		lm(as.formula(form), data = alldat)#
	}#
	)#
lapply(singregs, function(x) length(residuals(x)) )
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rnorm(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		lm(as.formula(form), data = alldat)#
	}#
	)#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
resid(reg)
singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		resid(reg)#
	}#
	)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rnorm(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		mean(resid(reg))#
	}#
	)#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
min(abs(singregs))
lapply(singregs, function(regs) min(abs(regs)))
min(singregs)
min(unlist(singregs))
which(unlist(singregs) == min(unlist(singregs)))
which(singregs == min(unlist(singregs)))
which(singregs == min(abs(unlist(singregs))))
dvdat <- as.data.frame(rbinom(nrow(IVdat)))
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat)))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		mean(resid(reg))#
	}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		mean(resid(reg))#
	}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
dvdat
as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		mean(resid(reg))#
	}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		critergen(predict(ptdat), fdf[,dvname])#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
ptdat
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		critergen(predict(reg, ptdat), fdf[,dvname])#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
singregs
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = T))#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
rm(list = ls())
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, aivdat, Ivys) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #Guaranteed to give each IV its own iteration. Not strictly needed#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
aivdat
IVdat
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, Ivys) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #Guaranteed to give each IV its own iteration. Not strictly needed#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #Guaranteed to give each IV its own iteration. Not strictly needed#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:1){ #Guaranteed to give each IV its own iteration. Not strictly needed#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:2){ #Guaranteed to give each IV its own iteration. Not strictly needed#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:3){ #Guaranteed to give each IV its own iteration. Not strictly needed#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:4){ #Guaranteed to give each IV its own iteration. Not strictly needed#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:4){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		aivs <-  c(aivs, bestvar)#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
aivs
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:4){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		print(aivs <-  c(aivs, bestvar))#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:4){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivs, yes = break ,no = aivs <-  c(aivs, bestvar))#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 3)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:4){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivs, yes = break ,no = aivs <-  c(aivs, bestvar))#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 7)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivs, yes = break ,no = aivs <-  c(aivs, bestvar))#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 7)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivs, yes = break ,no = aivs <-  c(aivs, bestvar))#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 4)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivs, yes = break ,no = aivs <-  c(aivs, bestvar))#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
# Deevname <- names(dvdat)#
# Ivynames <- names(Ivys)#
# aivnames <- names(aivdat)#
# df <- fdf#
#
# # #create besiva function#
BeSiVa <- function(Deevname, Ivynames, aivnames, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	aivdat <- df[, colnames(df) %in% aivnames] #
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = names(aivdat), famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivs, yes = break ,no = aivs <-  c(aivs, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivs#
#
	}#
# #define your dummy information#
 aivs = c('X1', 'X3')#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
BeSiVa(names(dvdat), names(IVdat	[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
