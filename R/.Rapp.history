<<<<<<< Updated upstream
=======
lastcol <- {}#
for( i in colnames(ind.var)) {#
	# print(i)#
	lastcol  <- c(lastcol, i)#
	print(lastcol)#
	}
# How to do it with a for loop:#
lastcol <- {}#
for( i in colnames(ind.var)) {#
	lastcol  <- c(lastcol, i)#
	print(lastcol)#
	}
# How to do it with a for loop:#
lastcol <- {}#
for( i in colnames(ind.var)) {#
	lastcol  <- c(lastcol, i) #how to capture this...#
	print(paste(lastcol, collapse = '+'))#
	}
lastcol <- {}#
for( i in colnames(ind.var)) {#
	lastcol  <- c(lastcol, i) #how to capture this...#
	print(paste(lastcol, collapse = ' + '))#
	}
lapply(colnames(ind.var), FUN = function(x) lastcol <- c(lastcol,x)
)
lapply(colnames(ind.var), FUN = function(x){ lastcol2 <- c(lastcol2,x)}#
)
lapply(colnames(ind.var), FUN = function(x, lastcol2 = {}){ lastcol2 <- c(lastcol2,x)}#
)
lapply(colnames(ind.var), FUN = function(x){ #
	lastcol2 <- x#
	lastcol2 <- c(lastcol2,x)#
	}#
)
lapply(colnames(ind.var), FUN = function(x){ #
	lastcol2 <- {}#
	lastcol2 <- c(lastcol2,x)#
	}#
)
lapply(colnames(ind.var), FUN = function(x){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info...#
	}#
)
lapply(colnames(ind.var), FUN = function(x, lastcol2){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info...#
	}#
)
lapply(colnames(ind.var), FUN = function(x, lastcol2 = y){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info...#
	}#
)
lapply(colnames(ind.var), FUN = function(y){ #
lapply(colnames(ind.var), FUN = function(x, lastcol2 = y){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info...#
	}#
)#
}#
)
lapply(colnames(ind.var), FUN = function(x, lastcol2 = 7){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info...#
	}#
)
gary = 'X3'#
lapply(colnames(ind.var), FUN = function(x, lastcol2 = gary){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info... There's got to be a way to dynamically control lastcol2 from the outside#
	}#
)
# Iter practice II#
# Created 12/23/14#
# A Ben Rogers Joint#
# Last Edited 12/23/14#
#
# Preamble: This code replicates an example I found of a way to use lapply to work of ver multiple columns in a regression#
#
set.seed(1000)#
values <- runif(50) #Select 50 random Values from the uniform distribution #
values[sample(1:length(values), 10)] <- NA # add some random fluctuations to the data, apparently just for fun#
ind.var <- data.frame(matrix(values, ncol = 5)) # and make that into a data frame#
#
# Make a dependent variable#
dep <- runif(10)#
dep#
#
#create regression formula between each column in the dataframe against the dv#
#
oneVRegNames <-  lapply(colnames(ind.var), function(x) { form.reg <- paste('dep ~ ', x ) }) # What is happening here is that I am applying the function that pastes the "dep ~" to each value in the colnames of ind.var. I do not see a difference between using paste and paste0 in the function I created. I am using paste instead.#
#Now let us create a function that lets us make regressions with this technique#
#
oneVRegs <-  lapply(colnames(ind.var), function(x) { #
	form.reg <- paste('dep ~ ', x ) #
	lm(form.reg, data = ind.var)#
	}) # Now, instead of returning the text, as seen in oneVarRegNames, we actually return the regressions in the list. What I do not understand is how the code understands what ind.var is if we didn't pass it into the function. Note: It still worked despite using paste!!!#
# try it with apply instead of lapply#
#
oneVRegs2 <-  apply(ind.var, MARGIN = 2, function(x) {#
	lm(dep ~ x, data = ind.var)#
	}#
) #Ok. This makes more sense than the one we were using previously, but#
#
# Try to figure out how to make it create a set that starts with just one and adds variables by iteration, without resorting to for loops#
#
dualIter <-  #
lapply( colnames(ind.var), function(y){#
#
	x <- lapply(colnames(ind.var), function(x) {paste(x,y)#
		})#
	})#
#This thing iterates first by chainging all the columns in the x, then changing the column in y, and could hypothetically iterate all dual combinations of x, with repeats.#
#
# # Still no clue how to create the output#
# X1#
# X1 + X2#
# X1 + X2 + X3#
# X1 + X2 + X3 + X4#
# X1 + X2 + X3 + X4 + X5#
# # Using only the apply family#
#
# I'd need to figure out how to store the old output somewhere#
#
# How to do it with a for loop:#
lastcol <- {}#
for( i in colnames(ind.var)) {#
	lastcol  <- c(lastcol, i) #how to capture this...#
	print(paste(lastcol, collapse = ' + '))#
	}#
lapply(colnames(ind.var), function(gary){#
u <-  lapply(colnames(ind.var), FUN = function(x, lastcol2 = gary){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info... There's got to be a way to dynamically control lastcol2 from the outside#
	})#
	})
lapply(colnames(ind.var), function(gary){#
u <-  lapply(colnames(ind.var), FUN = function(x, lastcol2 = gary){ #
	lastcol2 <- c(lastcol2,x) #trying the same way, but I can't figure out how to make it store the info... There's got to be a way to dynamically control lastcol2 from the outside#
	})#
	})
u <-  lapply(colnames(ind.var), FUN = function(x){
print(x)
})
u
# Iter practice II#
# Created 12/23/14#
# A Ben Rogers Joint#
# Last Edited 12/23/14#
#
# Preamble: This code replicates an example I found of a way to use lapply to work of ver multiple columns in a regression#
#
set.seed(1000)#
values <- runif(50) #Select 50 random Values from the uniform distribution #
values[sample(1:length(values), 10)] <- NA # add some random fluctuations to the data, apparently just for fun#
ind.var <- data.frame(matrix(values, ncol = 5)) # and make that into a data frame#
#
# Make a dependent variable#
dep <- runif(10)#
dep#
#
#create regression formula between each column in the dataframe against the dv#
#
oneVRegNames <-  lapply(colnames(ind.var), function(x) { form.reg <- paste('dep ~ ', x ) }) # What is happening here is that I am applying the function that pastes the "dep ~" to each value in the colnames of ind.var. I do not see a difference between using paste and paste0 in the function I created. I am using paste instead.#
#Now let us create a function that lets us make regressions with this technique#
#
oneVRegs <-  lapply(colnames(ind.var), function(x) { #
	form.reg <- paste('dep ~ ', x ) #
	lm(form.reg, data = ind.var)#
	}) # Now, instead of returning the text, as seen in oneVarRegNames, we actually return the regressions in the list. What I do not understand is how the code understands what ind.var is if we didn't pass it into the function. Note: It still worked despite using paste!!!#
# try it with apply instead of lapply#
#
oneVRegs2 <-  apply(ind.var, MARGIN = 2, function(x) {#
	lm(dep ~ x, data = ind.var)#
	}#
) #Ok. This makes more sense than the one we were using previously, but#
#
# Try to figure out how to make it create a set that starts with just one and adds variables by iteration, without resorting to for loops#
#
dualIter <-  #
lapply( colnames(ind.var), function(y){#
#
	x <- lapply(colnames(ind.var), function(x) {paste(x,y)#
		})#
	})#
#This thing iterates first by chainging all the columns in the x, then changing the column in y, and could hypothetically iterate all dual combinations of x, with repeats.#
#
# # Still no clue how to create the output#
# X1#
# X1 + X2#
# X1 + X2 + X3#
# X1 + X2 + X3 + X4#
# X1 + X2 + X3 + X4 + X5#
# # Using only the apply family#
#
# I'd need to figure out how to store the old output somewhere#
#
# How to do it with a for loop:#
lastcol <- {}#
for( i in colnames(ind.var)) {#
	lastcol  <- c(lastcol, i) #how to capture this...#
	print(paste(lastcol, collapse = ' + '))#
	}#
	u <-  lapply(colnames(ind.var), FUN = function(x){ 	#
		print(x)#
	})
u <-  lapply(colnames(ind.var), FUN = function(x){ 	#
		print(x)#
		x#
	})
u
v <- lapply(colnames(ind.var), function(y){#
	u <-  lapply(colnames(ind.var), FUN = function(x){ 	#
		print(x)#
		x#
	})})
colnames(ind.var)
v <- lapply(u, function(y) {})
v
u <-  as.data.frame(lapply(colnames(ind.var), FUN = function(x){ 	#
		print(x)#
		x#
	}))
u
u <-  t(as.data.frame(lapply(colnames(ind.var), FUN = function(x){ 	#
		print(x)#
		x#
	})))
u
v <- lapply(u, function(y) {#
	yprior <- y#
	paste(y,yprior)#
})
v
v <- lapply(u, function(y) {#
		paste(y,yprior)#
	yprior <- y#
})
v <- lapply(u, function(y, yprior = u[1]) {#
		paste(y,yprior)#
	yprior <- y#
})
v
v <- lapply(u, function(y, yprior = u[1]) {#
	print(paste(y,yprior))#
	yprior <- y#
})
x <- apply(ind.var, 2, function(x) glm(dep ~ x, data = ind.var) )
# Iter practice II#
# Created 12/23/14#
# A Ben Rogers Joint#
# Last Edited 12/23/14#
#
# Preamble: This code replicates an example I found of a way to use lapply to work of ver multiple columns in a regression#
#
set.seed(1000)#
values <- runif(50) #Select 50 random Values from the uniform distribution #
values[sample(1:length(values), 10)] <- NA # add some random fluctuations to the data, apparently just for fun#
ind.var <- data.frame(matrix(values, ncol = 5)) # and make that into a data frame#
#
# Make a dependent variable#
dep <- runif(10)#
dep#
#
#create regression formula between each column in the dataframe against the dv#
#
oneVRegNames <-  lapply(colnames(ind.var), function(x) { form.reg <- paste('dep ~ ', x ) }) # What is happening here is that I am applying the function that pastes the "dep ~" to each value in the colnames of ind.var. I do not see a difference between using paste and paste0 in the function I created. I am using paste instead.#
#Now let us create a function that lets us make regressions with this technique#
#
oneVRegs <-  lapply(colnames(ind.var), function(x) { #
	form.reg <- paste('dep ~ ', x ) #
	lm(form.reg, data = ind.var)#
	}) # Now, instead of returning the text, as seen in oneVarRegNames, we actually return the regressions in the list. What I do not understand is how the code understands what ind.var is if we didn't pass it into the function. Note: It still worked despite using paste!!!#
# try it with apply instead of lapply#
#
oneVRegs2 <-  apply(ind.var, MARGIN = 2, function(x) {#
	lm(dep ~ x, data = ind.var)#
	}#
) #Ok. This makes more sense than the one we were using previously, but#
#
# Try to figure out how to make it create a set that starts with just one and adds variables by iteration, without resorting to for loops#
#
dualIter <-  #
lapply( colnames(ind.var), function(y){#
#
	x <- lapply(colnames(ind.var), function(x) {paste(x,y)#
		})#
	})#
#This thing iterates first by chainging all the columns in the x, then changing the column in y, and could hypothetically iterate all dual combinations of x, with repeats.#
#
# # Still no clue how to create the output#
# X1#
# X1 + X2#
# X1 + X2 + X3#
# X1 + X2 + X3 + X4#
# X1 + X2 + X3 + X4 + X5#
# # Using only the apply family#
#
# I'd need to figure out how to store the old output somewhere#
#
# How to do it with a for loop:#
lastcol <- {}#
for( i in colnames(ind.var)) {#
	lastcol  <- c(lastcol, i) #how to capture this...#
	print(paste(lastcol, collapse = ' + '))#
	}#
	u <-  t(as.data.frame(lapply(colnames(ind.var), FUN = function(x){ 	#
		print(x)#
		x#
	})))#
#
v <- lapply(u, function(y) {#
	print(paste(y,yprior))#
})#
x <- apply(ind.var, 2, function(x) glm(dep ~ x, data = ind.var) )
x
matrix(data = NA, ncol = 10, nrow = 30)
data.frame(matrix(data = NA, ncol = 10, nrow = 30))
lapply(IVDat, function(x) x <- rnorm(length(x)))
lapply(IVDat, function(x) x <- rnorm(nrow(IVDat)))
lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 30))
lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))
as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat))))
set.seed(12345) # so it's replicable
>>>>>>> Stashed changes
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X2'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivs, yes = break ,no = aivs <-  c(aivs, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat))#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X2'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
		rm(bestvar)#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
singregs == max(unlist(singregs))) - 1
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X2'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
max(unlist(singregs))
bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs.
names(Ivys)[which(singregs == max(unlist(singregs))) - 1]
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .8)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X2'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar[1])) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .8)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X2'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
Ivys[1]
ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1]; aivnames = names(Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )
ifelse(is.null(aivnames) == T, aivdat <-  Ivys[1]; aivnames <-  names(Ivys[1], aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, {aivdat <-  Ivys[1]; aivnames <-  names(Ivys[1])}, aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, {aivdat <-  Ivys[1]; aivnames <-  names(Ivys[1])}, aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	ifelse(is.null(aivnames) == T, {aivdat <-  Ivys[1]; aivnames <-  names(Ivys[1])}, aivdat <- Ivys[,colnames(Ivys) %in% aivnames] )#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(is.null(aivees) == T, yes =, no =)#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
names(Ivys)[1]
ifelse(is.null(aivees) == T, yes = Ivform <- names(col), no =)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(is.null(aivees) == T, yes = Ivform <- names(col), no =)#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(is.null(aivees) == T, yes = Ivform <- names(col), no =print('') )#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
ifelse(is.null(aivees) == T & col == '', next, print(col))
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
		ifelse(is.null(aivees) == T & col == '', next, print(col))#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(c('', Ivynames), FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
		ifelse(is.null(aivees) == T & col == '', break, print(col))#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
ifelse( aivnames == NULL , LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( aivnames == NULL , LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))
aivnames
LapIvys <- Ivynames
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( aivnames == NULL, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))
Ivynames
IVdat[,4]
names(IVdat)[4]
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 500))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating th# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)#
is.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 500))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .8)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 500))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating th# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 500))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating th# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts#
			ifelse(as.character(col) == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames))#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			print(reg <-  glm(as.formula(form), data = alldat, family = famiglia))	#Perform the regression#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
summary(reg)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames)) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			summary(reg)#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 1000))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .8)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames, LapIvys <-  c('', Ivynames)) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
length(aivnames)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, LapIvys <- Ivynames; offsettr <- 0, LapIvys <-  c('', Ivynames), offsettr <- 1) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsetr] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames), offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsetr] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames), offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- NULL#
fam = 'binomial'#
niter <- 1#
df <- fdf#
offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames), offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames), offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 0] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames), offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - 1] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames), offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract 1 since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames), offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
print(offsettr)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
		bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr]
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			c(reg, crit)#
			}#
		)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			c(reg, crit)#
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
			bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	for(u in 1:niter){ #determines number of iterations.#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			crit#
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
			bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#
	aivnames#
#
	# }#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	# for(u in 1:niter){ #determines number of rounds of variable consideration (NVar).#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			crit#
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
			bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the same results from#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 # }	#Close NVar loop#
	aivnames#
#
	# } #Close function#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
offsettr
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 1000))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,4] + rnorm(nrow(IVdat), mean = 0, sd = .8)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
Ivys
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	# for(u in 1:niter){ #determines number of rounds of variable consideration (NVar).#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			crit#
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
			bestvar <-  names(Ivys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the results from one variable over is still a bug I am working on.#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 # }	#Close NVar loop#
	aivnames#
#
	# } #Close function#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
names(Ivys)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	# for(u in 1:niter){ #determines number of rounds of variable consideration (NVar).#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			crit#
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
			bestvar <-  names(LapIvys)[which(singregs == max(unlist(singregs))) - offsettr] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the results from one variable over is still a bug I am working on.#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 # }	#Close NVar loop#
	aivnames#
#
	# } #Close function#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
LapIvys
which(singregs == max(unlist(singregs))) - offsettr
names(LapIvys)[which(singregs == max(unlist(singregs))) - offsettr]
bestvar <-  names(LapIvys)[[which(singregs == max(unlist(singregs))) - offsettr]] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the results from one variable over is still a bug I am working on.
bestvar
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	# for(u in 1:niter){ #determines number of rounds of variable consideration (NVar).#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			crit#
			}#
		)#
			which(singregs == max(unlist(singregs)))	#
			bestvar <-  LapIvys[which(singregs == max(unlist(singregs)))] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the results from one variable over is still a bug I am working on.#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 # }	#Close NVar loop#
	aivnames#
#
	# } #Close function#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
IVdat[,3]
head(IVdat[, IVsamp])\
head(IVdat[, IVsamp])
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	# for(u in 1:niter){ #determines number of rounds of variable consideration (NVar).#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			crit#
			}#
		)#
			# which(singregs == max(unlist(singregs)))	#
			bestvar <-  LapIvys[which(singregs == max(unlist(singregs)))] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the results from one variable over is still a bug I am working on.#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 # }	#Close NVar loop#
	aivnames#
#
	# } #Close function#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
Ivynames <- names(IVdat)#
aivnames <- 'X1'#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	for(u in 1:niter){ #determines number of rounds of variable consideration (NVar).#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			crit#
			}#
		)#
			# which(singregs == max(unlist(singregs)))	#
			bestvar <-  LapIvys[which(singregs == max(unlist(singregs)))] #Give me the biggest value of singregs, and make sure to subtract offsettr since we've added an AIV regression in singregs. #Turns out that the which command gives us all of the answers with the highest result. Why we get the results from one variable over is still a bug I am working on.#
		ifelse(test = bestvar %in% aivnames, yes = break, no = aivnames <-  c(aivnames, bestvar)) #If bestvar has already been found by the algorithm, exit the loop and return only the aivs that matter. If it hasn't, add bestvar to aivs#
	 }	#Close NVar loop#
	aivnames#
#
	# } #Close function#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
which(singregs == max(unlist(singregs)))
LapIvys[which(singregs == max(unlist(singregs)))]
names(IVdat[,5])
names(IVdat)[5]
unlist(singregs)
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 1000))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- IVdat[,5] + rnorm(nrow(IVdat), mean = 0, sd = .8)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 1000))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(0:12, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .8)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 1000))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(0:12, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
IVdat[, IVsamp]
# Create Simulated Data Code#
# Created 12/30/14#
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(0:12, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
<<<<<<< Updated upstream
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Create Simulated Data Code#
# Created 12/30/14#
=======
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		mean(resid(reg))#
	}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
dvdat
as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))
# Besiva 2 #
# Created 12/24/14#
>>>>>>> Stashed changes
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 20))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(0:12, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(3,2,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
<<<<<<< Updated upstream
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
IVdat
# Create Simulated Data Code#
# Created 12/30/14#
=======
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		mean(resid(reg))#
	}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
>>>>>>> Stashed changes
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 20))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(0:12, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(2,3,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
<<<<<<< Updated upstream
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
seq2
# Create Simulated Data Code#
# Created 12/30/14#
=======
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		critergen(predict(ptdat), fdf[,dvname])#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
ptdat
# Besiva 2 #
# Created 12/24/14#
>>>>>>> Stashed changes
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 30))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(0:12, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(2,3,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
<<<<<<< Updated upstream
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
# Create Simulated Data Code#
# Created 12/30/14#
=======
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		critergen(predict(reg, ptdat), fdf[,dvname])#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
singregs
# Besiva 2 #
# Created 12/24/14#
>>>>>>> Stashed changes
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 40))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(0:12, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(2,3,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
<<<<<<< Updated upstream
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
relation
# Create Simulated Data Code#
# Created 12/30/14#
=======
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = T))#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
>>>>>>> Stashed changes
# A Ben Rogers Joint#
# Last Edited 12/30/14#
#
#Preamble: In order to better focus my BeSiVa Code, I've decided to separate out the simulated data code.#
rm(list = ls()) #
# Phase 1: Create Simulated Data#
set.seed(123456) # so it's replicable#
#
# make empty matrix where we can store IVs#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 40))#
IVdat <- as.data.frame(lapply(IVdat, function(x) x <- rnorm(nrow(IVdat), mean = 0, sd = 7))) #Fill that frame with data#
seq1 <- 1:nrow(IVdat)#
seq2 <- sample(-5:5, nrow(IVdat), replace = T)#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
# IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
IVsamp <- c(2,3,6,7,8) #No reason to keep generating this.#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
# dvdat <- dvdat + devseq#
#
relation <- seq2 + rnorm(nrow(IVdat), mean = 0, sd = .08)#
#
dvdat <- data.frame('DV' = exp(relation)/(1 + exp(relation))) #Get into logistic form#
dvdat <-  ifelse(dvdat >= .5, 1, 0)#
#
# #begin working on BeSiVa guts
dvdat
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
set.seed(12345)#
fdf <- data.frame(dvdat, IVdat) #create full dataframe like we'd see in real life#
head(fdf)#
Deevname <- colnames(dvdat)#
#
aivnames <- 'X5'#
Ivynames <- names(IVdat)[ !names(IVdat) %in% aivnames] #Make sure that Ivynames and aivnames are mutually exclusive#
fam = 'binomial'#
niter <- 1#
df <- fdf#
# offsettr <- 0#
# # #create besiva function#
# BeSiVa <- function(Deevname, Ivynames, aivnames = NULL, df, fam = 'gaussian', niter = 3){#
	#So this is the BeSiVa algorithm#
	# Deevname: the Dependent variable name. This is input as text#
	# Ivynames: the independent variable names. Input as a list of text#
	# aivnames: any always independent variables you'd like included, as text#
	# df: the dataframe #
	# fam: the family created by the glm function#
	# niter: the number of iterations used by the innermost loop, and a tuning parameter. Input as integer value#
	#define the data for each#
	Ivys <- df[, colnames(df) %in% Ivynames & !colnames(df) %in% aivnames]#
	Deev <- df[, colnames(df) %in% Deevname]#
	critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
	}#
	subsetter <- function(dataframe, sep = 10){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/sep)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
<<<<<<< Updated upstream
	}#
			ifelse( is.null(aivnames) == T, {LapIvys <- Ivynames; offsettr <- 0}, {LapIvys <-  c('', Ivynames); offsettr <- 1}) #if there are no aivs mentioned, make sure the first regression includes an IV. If there are, make sure that the first regression is blank (to account for only the aivs). In addition, create a value for offsettr#
	 # for(u in 1:niter){ #determines number of rounds of variable consideration (NVar).#
		#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
		singregs <-  lapply(LapIvys, FUN = function(col, dvname = Deevname, aivees = aivnames, famiglia = fam, alldat = df[-subsetter(df),], ptdat = df[subsetter(df),]){#
			ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
			Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste that into Ivform#
			print(form <- paste(dvname, '~', Ivform)) #Make and store a formula with IVfom and dvname as text together#
			reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
			print(summary(reg))#
			crit <-  critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
				#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
			rm(reg)#
			crit#
			}#
		)#
	  # }	#Close NVar loop#
	aivnames#
#
	# } #Close function#
# #define your dummy information#
# Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
# Deev <- dvdat#
# fam = 'binomial'#
# aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
# BeSiVa("DV", names(IVdat[,!names(IVdat) %in% aivs]), aivnames = aivs, df = fdf, niter = 8)
singregs
=======
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  lm(as.formula(form), data = alldat)	#
		print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = T))#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#
		print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = T))#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#
		print(critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = T))#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#
		critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = T)#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
singregs
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#
		critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = T)#
		}#
	)#
which(singregs == min(abs(unlist(singregs)))) #until we can get critergen to work via simulated data, this could be useful#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
print(singregs)
print(singregs$TRUE)
print(singregs[['TRUE']])
print(singregs['TRUE'])
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#
		critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)#
		}#
	)#
print(singregs['TRUE'])#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#
		critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F)#
		}#
	)#
print(singregs)#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
max(singregs)
max(unlist(singregs))
which(singregs == max(unlist(singregs)))
# Besiva 2 #
# Created 12/24/14#
# A Ben Rogers Joint#
# Last Edited 12/24/14#
#
# Preamble: using what we have done with iteration so far, we will create a new version of the BeSiVa algorithm that works from some simulated data#
critergen <- function( predicted, measured, fulltabl = FALSE ) {#
	predictedRes <- ifelse(predicted >= .5, 1,0)   #
	if (fulltabl == TRUE) return( prop.table(table(predictedRes == measured, exclude = NULL))) else return( prop.table(table(predictedRes == measured, exclude = NULL))['TRUE']) #output: % true in table of elastic net's predictions on test set#
}#
# Phase 1: Create Simulated Data#
set.seed(12345) # so it's replicable#
# make empty matrix to store IVs in#
IVdat <-  data.frame(matrix(data = NA, ncol = 10, nrow = 50))#
IVdat <- as.data.frame( lapply(IVdat, function(x) x <- rnorm(nrow(IVdat)))) #Fill that frame with data#
dvdat <- as.data.frame(rbinom(nrow(IVdat), size = 1, prob = 0.5))#
#
seq1 <- 1:nrow(IVdat)#
seq2 <- 1:nrow(IVdat) * 2#
negseq <- -1* 1:nrow(IVdat)#
countdown <- nrow(IVdat) + 1 + negseq#
seq7 <- seq2/2 * 7#
# devseq <- seq2#
seqlist <- list(seq1, seq2, negseq, countdown, seq7)#
#
IVsamp <- sample(length(IVdat), length(seqlist)) #create and store a sample of the columns equivalent to the length of seqlist, so that we can affect only those columns.#
#
IVdat[, IVsamp] <-  IVdat[, IVsamp] + as.data.frame(seqlist) #and add the information#
#
dvdat <- dvdat + devseq#
names(dvdat) <- 'DV'#
# #begin working on BeSiVa guts#
#define your dummy information#
aivs = c('X1', 'X3')#
Ivys <- IVdat[, !colnames(IVdat) %in% aivs]#
Deev <- dvdat#
fam = 'gaussian'#
aivdat <- IVdat[, colnames(IVdat) %in% aivs]#
names(aivdat)#
names(Ivys[3])#
#
fdf <- data.frame(Deev, aivdat, Ivys) #create full dataframe like we'd see in real life#
subsetter <- function(dataframe){ # make a function to take a dataframe and return rows that will become the pseudotest subset for besiva#
	fulllen <- nrow(dataframe) #Get and store the full length of the dataset#
	ptestlen <- round(fulllen/10)	#divide it by ten and store the rounded result#
	sample(fulllen, ptestlen)	#then get a sample from the rows that uses ptestlen as the #
}#
#lapply function that loops over all independent variables in Ivys and makes a linear regression with them#
	singregs <-  lapply(c('', names(Ivys)), FUN = function(col, dvname = names(Deev), aivees = names(aivdat), famiglia = fam, alldat = fdf[-subsetter(fdf),], ptdat = fdf[subsetter(fdf),]){#
#
		ifelse(col == '', Ivform <-  paste(aivees, collapse = '+'), #if there's nothing in the column, paste the aivs together.#
		Ivform <-  paste(paste(aivees, collapse = '+'), col, sep = ' + ')) #otherwise, add in the new column and paste taht in#
		form <- paste(dvname, '~', Ivform) #Make and store a formula with IVfom and dvname as text together#
		reg <-  glm(as.formula(form), data = alldat, family = famiglia)	#Perform the regression#
		critergen(predict(reg, ptdat), fdf[,dvname], fulltabl = F) #generate the criterion.#
			#Just realized, critergen will need to be changed if we ever want to use it on something else. Residuals should work for continuous, but need to brush up on deviance. #
		}#
	)#
print(singregs)#
#
which(singregs == max(unlist(singregs))) # get the biggest in the list of ivs#
#
#create besiva function#
BeSiVa <- function(Deev, Ivys, aivs, fam = 'gaussian'){#
#So this is the BeSiVa algorithm#
	# Deev: the Dependent variable data. This si input as a column of data#
	# Ivys: the independent variable data. Input as a dataframe or list#
	# aivs: any always independent variables you'd like included, #
	# fam: the family created by the glm function#
	}
>>>>>>> Stashed changes
